---
title: "Evolution of solar energy production and use."
author: "Laia Porcar, Luis Marcos LÃ³pez, Philippe Robert"
date: "11/08/2022"
output:
  html_document:
    keep_md: yes
    toc: yes
    df_print: kable
  pdf_document:
    toc: yes
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(warn=-1)

```



```{r, results="hide", message = FALSE}
# Installs
# install.packages("caret")
# install.packages("car")
# install.packages("ggplot2")
# install.packages("devtools")  


# Libraries
library(knitr)
library(tidyverse)
library(ggplot2)
library(dplyr)
library(ggcorrplot)
library(devtools) 
library(caret)
library(car)
library(kableExtra)
library(ggpubr)
library(readxl)
library(lmtest) 
library(forecast)
library(DIMORA)
library(reshape2)
library(zoo)
library(sm)
library(splines)


```

# Read and prepare datasets

```{r results = 'asis'}
# Read the dataset
file_path <- getwd()
paste(file_path)


# Per capita energy consumption from solar
df_capita_solar <- read.csv(paste0(file_path, "/per-capita-solar.csv"),header=TRUE)
# Solar PV module prices
df_price <- read.csv(paste0(file_path, "/solar-pv-prices.csv"),header=TRUE)
# Share of electricity production from solar
df_share <- read.csv(paste0(file_path, "/share-electricity-solar.csv"),header=TRUE)
# Installed solar energy capacity
df_capacity <- read.csv(paste0(file_path, "/installed-solar-PV-capacity.csv"),header=TRUE)
# Per capita energy consumption from nuclear
df_capita_nuclear <- read.csv(paste0(file_path, "/per-capita-nuclear.csv"),header=TRUE)
# Per capita energy consumption from wind
df_capita_wind <- read.csv(paste0(file_path, "/per-capita-wind.csv"),header=TRUE)
# Per capita energy consumption from fossil
df_capita_fossil <- read.csv(paste0(file_path, "/fossil-fuels-per-capita.csv"),header=TRUE)
# Per capita energy consumption from oil
df_capita_oil <- read.csv(paste0(file_path, "/per-capita-oil.csv"),header=TRUE)
# Per capita energy consumption from gas
df_capita_gas <- read.csv(paste0(file_path, "/per-capita-gas.csv"),header=TRUE)
# Per capita energy consumption from coal
df_capita_coal <- read.csv(paste0(file_path, "/coal-consumption-per-capita.csv"),header=TRUE)


# df_capacity[1:50,] %>%
#   kable(format = "html", col.names = colnames(df_capacity)) %>%
#   kable_styling() %>%
#   kableExtra::scroll_box(width = "100%", height = "300px")


```


```{r results = 'asis'}

entity <- 'Spain'



share <- df_share %>% filter(Entity == entity) %>% select(-c(Entity, Code))
price <- select(df_price,-c(Entity, Code))
capacity <- df_capacity %>% filter(Entity == entity) %>% select(-c(Entity, Code))

capita_solar_spain <- df_capita_solar %>% filter(Entity == entity) %>% select(-c(Entity, Code))
capita_nuclear <- df_capita_nuclear %>% filter(Entity == entity) %>% select(-c(Entity, Code))
capita_wind <- df_capita_wind %>% filter(Entity == entity) %>% select(-c(Entity, Code))
capita_fossil <- df_capita_fossil %>% filter(Entity == entity) %>% select(-c(Entity, Code))
capita_gas <- df_capita_gas %>% filter(Entity == entity) %>% select(-c(Entity, Code))
capita_oil <- df_capita_oil %>% filter(Entity == entity) %>% select(-c(Entity, Code))
capita_coal <- df_capita_coal %>% filter(Entity == entity) %>% select(-c(Entity, Code))

capita_solar_germany <- df_capita_solar %>% filter(Entity == 'Germany') %>% select(-c(Entity, Code))
capita_solar_usa <- df_capita_solar %>% filter(Entity == 'United States') %>% select(-c(Entity, Code))
capita_solar_china <- df_capita_solar %>% filter(Entity == 'China') %>% select(-c(Entity, Code))





df <- merge(share, capacity, by="Year", all = TRUE) #to fill the non existent values with NA
df <- merge(df,price,by="Year", all = TRUE)
df <- merge(df,capita_solar_spain,by="Year", all = TRUE)
df <- merge(df,capita_nuclear,by="Year", all = TRUE)
df <- merge(df,capita_wind,by="Year", all = TRUE)
df <- merge(df,capita_coal,by="Year", all = TRUE)
df <- merge(df,capita_fossil,by="Year", all = TRUE)
df <- merge(df,capita_gas,by="Year", all = TRUE)
df <- merge(df,capita_oil,by="Year", all = TRUE)
df <- merge(df,capita_solar_germany,by="Year", all = TRUE)
df <- merge(df,capita_solar_usa,by="Year", all = TRUE)
df <- merge(df,capita_solar_china,by="Year", all = TRUE)

df[is.na(df)] <- 0 #change NA to 0

# # # Change names of columns
colnames(df) <- c("Year", "Share.from.solar" ,"PV.capacity", "PV.price", "Capita.solar.spain", "Capita.nuclear", "Capita.wind", "Capita.coal", "Capita.fossil", "Capita.gas", "Capita.oil", "Capita.solar.germany", "Capita.solar.usa", "Capita.solar.china")


```


# Apply stuff from the lectures

Check some info of the data

```{r results = 'asis'}

str(df) #str() is an alternative to summary() but more compact

```


Take the column we want to study in depth (per capita solar energy consumption in Spain)

```{r results = 'asis'}

cap_solar_SP <- df$Capita.solar.spain[25:57] #25 because first data start there
tt<- 1:NROW(cap_solar_SP)

```

Plot the data and the autocorrelation plot.

```{r results = 'asis'}

plot(tt, cap_solar_SP, xlab="Time", ylab="Solar per capita kWh") #from 1989 to 2021
acf(cap_solar_SP) #strong correlation with lag values, correlation is negative after 10 years.


```



```{r results = 'asis'}

##fit a linear regression model           (not sure if useful method)
fit1 <- lm(cap_solar_SP ~ tt)
summary(fit1)

##plot of the model
plot(tt, cap_solar_SP, xlab="Time", ylab="Solar per capita kWh")
abline(fit1, col=3)

##check the residuals? are they autocorrelated? Test of DW
dwtest(fit1)

##check the residuals
resfit1<- residuals(fit1)
plot(resfit1,xlab="Time", ylab="residuals" )


```



```{r results = 'asis'}

##let us do the same with a linear model for time series, so we transform the data into a ts object
cap_solar_SP.ts <- ts(cap_solar_SP)
ts.plot(cap_solar_SP.ts, type="o")

## we fit a linear model with the tslm function
fitts<- tslm(cap_solar_SP.ts~trend)

###obviously it gives the same results of the first model
summary(fitts)

dwtest(fitts)

```



```{r results = 'asis'}

#plot(cap_solar_SP, type="b")
plot(cap_solar_SP, type= "b",xlab="Year", ylab="Solar per capita kWh",  pch=16, lty=3, xaxt="n", cex=0.6)
plot(cumsum(cap_solar_SP), type="b", xlab="Year", ylab="Solar per capita kWh",  pch=16, lty=3, xaxt="n", cex=0.6)

```

# Bass Model

Let's now fit a Bass model.

```{r results = 'asis'}

bm_SP<-BM(cap_solar_SP,display = T)
summary(bm_SP)

###prediction (out-of-sample)
pred_bm_SP<- predict(bm_SP, newx=c(1:50))
pred.instcap_SP<- make.instantaneous(pred_bm_SP)

###plot of fitted model 
plot(cap_solar_SP, type= "b",xlab="Year", ylab="Solar per capita kWh",  pch=16, lty=3, xaxt="n", cex=0.6)
lines(pred.instcap_SP, lwd=2, col=2)

```

Predict (out-of-sample).

```{r results = 'asis'}

pred_bm_SP_oos<- predict(bm_SP, newx=c(1:50))
pred.inst_SP_oos<- make.instantaneous(pred_bm_SP_oos)

```

Plot of fitted model with out of sample predictions

```{r results = 'asis'}

### 
plot(cap_solar_SP, type= "b",xlab="Year", ylab="Solar per capita kWh",  pch=16, lty=3, xaxt="n", cex=0.6)
lines(pred.inst_SP_oos, lwd=2, col=2)

```


Let's see what happens when we estimate the model with 75 percent of the data.

```{r results = 'asis'}

bm_SP75<-BM(cap_solar_SP[1:25],display = T)
summary(bm_SP75)

# prediction
pred_bm_SP75<- predict(bm_SP75, newx=c(1:50))
pred.inst_SP75<- make.instantaneous(pred_SP75)

# plotting
plot(cap_solar_SP, type= "b",xlab="Year", ylab="Solar per capita kWh",  pch=16, lty=3, xaxt="n", cex=0.6)
lines(pred.inst_SP75, lwd=2, col=2)

```


Plot both models to compare them. 

```{r results = 'asis'}

###Comparison between models (instantaneous)
###instantaneous
plot(cap_solar_SP, type= "b",xlab="Year", ylab="Solar per capita kWh",  pch=16, lty=3, xaxt="n", cex=0.6)
lines(pred.instcap_SP75, lwd=2, col=2)
lines(pred.instcap_SP, lwd=2, col=4)

###Comparison between models (cumulative)
plot(cumsum(cap_solar_SP), type= "b",xlab="Year", ylab="Annual sales",  pch=16, lty=3, xaxt="n", cex=0.6)
lines(pred_bm_SP75, lwd=2, col=2)
lines(pred_bm_SP, lwd=2, col=4)

```

# Generalized bass model

```{r results = 'asis'}


 
# GBMe2 <- GBM(cap_solar_SP,shock = "exp",nshock = 2,prelimestimates = c(1.243162e+04, 2.424655e-05, 3.283666e-01, 20, -0.1,0.2, 30,0.5,0.6))
# 
# GBMe2 <- GBM(cap_solar_SP,shock = "exp",nshock = 2,prelimestimates = c(1.243162e+04, 2.424655e-05, 3.283666e-01, 20, -0.1,0.2, 30,0.5,0.7))


GBM_SP_e2 <- GBM(cap_solar_SP,shock = "exp",nshock = 2,prelimestimates = c(1.243162e+04, 2.424655e-05, 3.283666e-01, 19, -0.1,0.2, 29,0.2,0.4))
summary(GBM_SP_e2)


# Try with three shocks
# GBMe2 <- GBM(cap_solar_SP,shock = "exp",nshock = 3,prelimestimates = c(1.243162e+04, 2.424655e-05, 3.283666e-01, 18,-0.6,0.3, 21, -0.4,0.4, 29,0.38,0.5))

###

pred_GBM_SP_e2<- predict(GBM_SP_e2, newx=c(1:50))
 pred_GBM_SP_e2.inst<- make.instantaneous(pred_GBM_SP_e2)

plot(cap_solar_SP, type= "b",xlab="Quarter", ylab="Quarterly revenues",  pch=16, lty=3, cex=0.6, xlim=c(1,60))
lines(pred_GBM_SP_e2.inst, lwd=2, col=2)




```

# GGM

```{r results = 'asis'}

######GGM 
GGM_SP<- GGM(cap_solar_SP, prelimestimates=c(1.243162e+04, 0.01, 0.01,  2.424655e-05, 3.283666e-01))
summary(GGM_SP)

pred_GGM_SP<- predict(GGM_SP, newx=c(1:60))
pred_GGM_SP.inst<- make.instantaneous(pred_GGM_SP)

plot(cap_solar_SP, type= "b",xlab="Quarter", ylab="Quarterly revenues",  pch=16, lty=3, cex=0.6, xlim=c(1,60))
lines(pred_GGM_SP.inst, lwd=2, col=2)

```


```{r results = 'asis'}

###Analysis of residuals
res_GGM_SP<- residuals(GGM_SP)
acf<- acf(residuals(GGM_SP))


fit_GGM_SP<- fitted(GGM_SP)
fit_GGM_SP_inst<- make.instantaneous(fit_GGM_SP)

```


# Arima

```{r results = 'asis'}

# Let's begin with Arima

# autoplot(cap_solar_SP)

plot(cap_solar_SP)
Acf(cap_solar_SP)
Pacf(cap_solar_SP)

```


```{r results = 'asis'}
# Fit Arima model
arima1<- Arima(cap_solar_SP, order=c(2,1, 0))
fitted(arima1)

# See effect of differenciation 
diff1<- diff(cap_solar_SP) ##first difference
diff2<- diff(cap_solar_SP, lag=2)
tsdisplay(diff1)
tsdisplay(diff2)


# Analyze residuals
resid1<- residuals(arima1)
tsdisplay(resid1)

# Plot Arima model
plot(cap_solar_SP)
lines(fitted(arima1), col=2)

# Forecast
for1<- forecast(arima1)
plot(for1)

```


```{r results = 'asis'}

# Try autoarima
auto.a <- auto.arima(cap_solar_SP)
auto.a

# Plot fitting
plot(cap_solar_SP)
lines(fitted(auto.a), col=2)

# Do forecast
autoplot(forecast(auto.a))

#Check residuals
checkresiduals(auto.a)




```



```{r results = 'asis'}
# Let's see the influence of the price of PV modules

price <- df$PV.price[25:57]
plot(price)
acf(price)
pacf(price)


# armax1 <- Arima(cap_solar_SP, xreg = price, order = c(1,1,1))
armax1 <- auto.arima(cap_solar_SP, xreg = price)
summary(armax1)
res1 <- residuals(armax1)
Acf(res1)

fitted(armax1)
plot(cap_solar_SP)
lines(fitted(armax1), col = 2)


```



```{r results = 'asis'}

# Let's see the influence of the capacity of PV modules

capacity <- df$PV.capacity[25:57]
capacity.ts <- ts(capacity)
# ts.plot(capacity.ts, type="o")

plot(capacity)
acf(capacity)
pacf(capacity)

armax1 <- auto.arima(cap_solar_SP, xreg = capacity)
summary(armax1)
res1 <- residuals(armax1)
Acf(res1)

fitted(armax1)
plot(cap_solar_SP)
lines(fitted(armax1), col = 2)


```



```{r results = 'asis'}

mod <- tslm(cap_solar_SP.ts~trend+capacity.ts)
summary(mod)

fitted(mod)
plot(cap_solar_SP.ts)
lines(fitted(mod), col = 2)

# Analysis of residuals - autocorelation?
plot(residuals(mod))
dw <- dwtest(mod, alt="two.sided")
tsdisplay(residuals(mod))

aar <- auto.arima(residuals(mod))
fitted(aar)

plot(cap_solar_SP.ts)
lines(fitted(mod)+fitted(aar), col = 3)

```




```{r results = 'asis'}
#Inspecting if the installed solar energy capacity of Spain is influenced by the one of another country.

df_capacity_transformed <- df_capacity

#Create one columns per country, with years as row and solar capacity as value
df_capacity_transformed <-  dcast(df_capacity_transformed, Year ~ Entity) 

#remove all white space in name columns
names(df_capacity_transformed) <- gsub(" ", ".", names(df_capacity_transformed))

#Keep only countries
df_capacity_transformed <- df_capacity_transformed %>% select(-c("Africa.(BP)", "Asia", "Asia.Pacific.(BP)", "CIS.(BP)","Europe", "Europe.(BP)", "High-income.countries", "Lower-middle-income.countries", "Middle.East.(BP)", "North.America.(BP)", "Other.Africa.(BP)", "Other.Asia.Pacific.(BP)", "Other.CIS.(BP)", "Other.Europe.(BP)", "Other.Middle.East.(BP)", "Other.South.and.Central.America.(BP)", "South.and.Central.America.(BP)", "United.Arab.Emirates", "North.America", "South.Africa", "Upper-middle-income.countries", "World", "Oceania" ))


str((df_capacity_transformed))
df_capacity_transformed[is.na(df_capacity_transformed)] <- 0 #Convert NA to 0

#Convert df_capac_tansformed to a time series
#df_capac_transformed.zoo <- read.zoo(df_capac_transformed)
#df_capac_transformed.ts <- as.ts(df_capac_transformed.zoo) 

#Using Pearson correlation, Spain vs all
cor_spain_vs_all <- cor(df_capacity_transformed[ , colnames(df_capacity_transformed) != "Spain"], df_capacity_transformed$Spain)
cor_spain_vs_all #Portugal with 0.9449656, Belgium 0.9423068 and Australia 0.9409159 are the country with higher Pearson correlation. Lets look at cross-correlation function (using lagged values of these countrie to predict current value of Spain)

ccf_spain_portugal <- ccf(df_capacity_transformed$Portugal, df_capacity_transformed$Spain,26) 

ccf_spain_belgium <- ccf(df_capacity_transformed$Belgium, df_capac_transformed$Spain,26)

ccf_spain_australia <- ccf(df_capacity_transformed$Australia, df_capacity_transformed$Spain,26)
#from correlogram plot, it doesnt seems like the spending of any of theses three countries in solar capacity leads to en increase in spending in solar capacity for spain. They are correlatated, but the lagged values of theses three countries doesnt have a impact of current value of Spain, and it seems that is might be the opposite. 



#plotting Cross correlation function of every countries againts spain to see if we can see if some countries spedind leads to spain spending. I am not able to plot with the columns.
ccf_spain_vs_all <- sapply(df_capacity_transformed, function(col_names) ccf(col_names,df_capacity_transformed$Spain,26))
#from all correlogram, no lagged values of countries seems to influence spain spending.






```





```{r results = 'asis'}
#Analyszing relationship between Installed solar energy capacity and solar PV modul price

df_price_capacity <- df[32:57,] %>% select(Year, PV.capacity, PV.price) #[32:57] to avoid 0 values of df_price

#Creat variable time and variable to not affect df_price_cap
t <- 1:NROW(df_price_capacity)
df_p_c <- df_price_capacity

#make plot
plot(t, df_p_c$PV.capacity, xlab = "Time", ylab = "Solar Capacity")
plot(t, df_p_c$PV.price, xlab = "Time", ylab = "Solar PV Price")

ggplot(df_p_c, aes(t)) +                    
  geom_line(aes(y=df_p_c$PV.capacity, colour="Capacity")) +
  geom_line(aes(y=df_p_c$PV.price, colour="Price"))+
  scale_colour_manual("", 
                      breaks = c("Capacity", "Price"),
                      values = c("Capacity"="green", "Price"="red")) +
  xlab(" ") +
  scale_y_continuous("Amount", limits = c(0,10)) + 
  labs(title="Years")

#ACF
acf(df_p_c,15)
ccf(df_p_c$PV.capacity, df_p_c$PV.price,15)

#Fit linear regression model
fit1 <- lm(df_p_c$PV.price~ df_p_c$PV.capacity, df_p_c)
summary(fit1)
#summary analysis: Residual: average price of 4.34 for Solar PV modul. For an increase of 1 gigawatts, the price of PV modul drop of 0.50241usd$ per watts with a variation of 0.06389usd$ per watts. T-value significantly bigger than zero and their standard-errors, indicating that the coefficients are relatively bigger enough from their standor-errors. P-value smaller than 5% and three start, thus p-value significant enough to reject null hypothesis which mean there is a relationship between solar capacity and solar PV modul price. The residual standard error is 1.115, which represent 1.115/4.34312= 25.6% deviation error. R-squared of 0.7204, which mean that 72% of the variance of the solar PV modul price can be described by the solar capacity. F-Statistic larger than 1 significantly for 24 DF, meaning strong indication we can reject null hypothesis of no relationship.

##Plot of the model
plot(df_p_c$PV.capacity, df_p_c$PV.price, xlab="Solar Capacity", ylab="Solar PV Price")
abline(fit1, col=3) #The abline() function can be used to add vertical,
                     #horizontal or regression lines to plot.

##Check the residuals? are they autocorrelated? Test of DW
dwtest(fit1) #reject null hypothesis, thus they are autocorrelated.

##check the residuals
resfit<- residuals(fit1) 
plot(resfit,xlab="Solar Capacity", ylab="residuals" )

###Local regression
y <-  df_p_c$PV.price
x <-  df_p_c$PV.capacity
plot(x,y, xlab="Solar capacity", ylab="Solar PV modul price")

sm.regression(x, y, h= 10, add= T)

#lets increase the number of points where the function is calculated
sm.regression(x, y, h= 10, add= T, ngrid=200,col=2)

#Trying different value for h: higher h = smoother function.
sm.regression(x, y,   h = 30, ngrid=200, col=1)
sm.regression(x, y,   h = 50, add = T, ngrid=200, col=2)
sm.regression(x, y,   h = 5,  add = T, ngrid=200, col=3)
sm.regression(x, y,   h = 1,  add = T, col=3, ngrid=200)

#We add variability bands
sm.regression(x, y,   h = 30, ngrid=200, display="se")

###Loess (Locally Weighted Least Squares Regression). it uses more local data to estimate our Y variable. But it is also known as a variable bandwidth smoother, in that it uses a 'nearest neighbors' method to smooth.

lo1 <- loess.smooth(x,y) 
lines(lo1) #default span = 0.75
lo2 <- loess.smooth(x,y,span=0.9)
lines(lo2,col=2)
lo3 <- loess.smooth(x,y,span=0.4)
lines(lo3,col=3)

#another way to perform loess, performs directly the plot
#default span= 2/3
scatter.smooth(x,y) 
scatter.smooth(x,y, span=0.3)
scatter.smooth(x,y, span=0.3, evaluation=200)

###Regression splines (cubic splines)
plot(x,y,xlab="Solar capacity", ylab="Solar PV modul price")

#We select and identify the knots 'equispaced'
xi<-seq(min(x), max(x), length=4)

#2 internal knots
m1cc<-lm(y ~ bs(x, knots=xi[2:(length(xi)-1)], degree=3))

#Select 200 points
xxx<-seq(min(x),max(x),length=200)

#Make predictions by using the 'xxx' points
fit1<-predict(m1cc, data.frame(x=xxx))
plot(x,y,xlab="Solar capacity", ylab="Solar PV modul price")
lines(xxx,fit1,col=2)

######vertical lin3 to indicate the knots
abline(v=xi[2], lty=3)
abline(v=xi[3], lty=3)

###Selecting number of knots
plot(x,y,xlab="Solar capacity", ylab="Solar PV modul price")

# first model with 2 internal knots
m1cc<-lm(y~bs(x, df=5, degree=3)) 
fit1<-predict(m1cc, data.frame(x=xxx))
lines(xxx,fit1,col=4)

# second model with no internal knots 
m2cc <- lm(y ~ bs(x, df=3, degree=3)) 
fit2<-predict(m2cc,data.frame(x=xxx))

#plot(x,y,xlab="engine size", ylab="distance")
lines(xxx,fit2,col=3)

# Third model with 17 knots 
m3cc<-lm(y~bs(x,df=20,degree=3))
fit3<-predict(m3cc,data.frame(x=xxx))

#plot(x,y,xlab="engine size", ylab="distance")
lines(xxx,fit3,col=2)

###Smoothing splines
plot(x,y,xlab="engine size", ylab="distance")
s <- smooth.spline(x,y)
lines(s)

# Model 1
plot(x,y,xlab="engine size", ylab="distance")
s1 <- smooth.spline(x,y, lambda=0.0001)
lines(s1)

p1<- predict(s1, x=xxx)
lines(p1, col=2)

# Model 2
s2 <- smooth.spline(x,y, lambda=0.00001)
p2<- predict(s2, x=xxx)
lines(p2, col=3)

# Model 3
s3 <- smooth.spline(x,y, lambda=0.01)
p3<- predict(s3, x=xxx)
lines(p3, col=4)

# Model 4
s4 <- smooth.spline(x,y, lambda=1)
p4<- predict(s4, x=xxx)
lines(p4, col=4)

# Model 5
s5 <- smooth.spline(x,y, lambda=0.00000001)
p5<- predict(s5, x=xxx)
lines(p5, col=4)

```





```{r results = 'asis'}




```





```{r results = 'asis'}




```





```{r results = 'asis'}




```





```{r results = 'asis'}




```





```{r results = 'asis'}




```





```{r results = 'asis'}




```




```{r results = 'asis'}




```




```{r results = 'asis'}




```




```{r results = 'asis'}




```




```{r results = 'asis'}




```
