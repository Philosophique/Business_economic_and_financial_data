---
title: "Evolution of solar energy production and use."
author: "Laia Porcar, Luis Marcos LÃ³pez, Philippe Robert"
date: "11/08/2022"
output:
  html_document:
    keep_md: yes
    toc: yes
    df_print: kable
  pdf_document:
    toc: yes
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(warn=-1)

```



```{r, results="hide", message = FALSE}
# Installs
# install.packages("caret")
# install.packages("car")
# install.packages("ggplot2")
# install.packages("devtools")


# Libraries
library(knitr)
library(tidyverse)
library(ggplot2)
library(dplyr)
library(ggcorrplot)
library(devtools) 
library(caret)
library(car)
library(kableExtra)
library(ggpubr)
library(readxl)
library(lmtest) 
library(forecast)
library(DIMORA)
library(reshape2)
library(zoo)
library(sm)
library(splines)


```

# Read and prepare datasets

```{r results = 'asis'}
# Read the dataset
file_path <- getwd()
paste(file_path)

df_capac <- read.csv(paste0(file_path, "/installed-solar-PV-capacity.csv"),header=TRUE)
df_capit <- read.csv(paste0(file_path, "/per-capita-solar.csv"),header=TRUE)
df_prim <- read.csv(paste0(file_path, "/primary-energy-consumption-from-solar.csv"),header=TRUE)
df_shar <- read.csv(paste0(file_path, "/share-electricity-solar.csv"),header=TRUE)
df_consump <- read.csv(paste0(file_path, "/solar-energy-consumption.csv"),header=TRUE)
df_cumcapac <- read.csv(paste0(file_path, "/solar-pv-cumulative-capacity.csv"),header=TRUE)
df_price <- read.csv(paste0(file_path, "/solar-pv-prices.csv"),header=TRUE)
df_totconsumpcapita <- read.csv(paste0(file_path, "/per-capita-energy.csv"), header=TRUE)


df_capac[1:150,] %>%
  kable(format = "html", col.names = colnames(df_capac)) %>%
  kable_styling() %>%
  kableExtra::scroll_box(width = "100%", height = "300px")

df_capit[1:150,] %>%
  kable(format = "html", col.names = colnames(df_capit)) %>%
  kable_styling() %>%
  kableExtra::scroll_box(width = "100%", height = "300px")

df_prim[1:150,] %>%
  kable(format = "html", col.names = colnames(df_prim)) %>%
  kable_styling() %>%
  kableExtra::scroll_box(width = "100%", height = "300px")

df_shar[1:150,] %>%
  kable(format = "html", col.names = colnames(df_shar)) %>%
  kable_styling() %>%
  kableExtra::scroll_box(width = "100%", height = "300px")

df_consump[1:150,] %>%
  kable(format = "html", col.names = colnames(df_consump)) %>%
  kable_styling() %>%
  kableExtra::scroll_box(width = "100%", height = "300px")

df_cumcapac[1:150,] %>%
  kable(format = "html", col.names = colnames(df_cumcapac)) %>%
  kable_styling() %>%
  kableExtra::scroll_box(width = "100%", height = "300px")

df_price[1:150,] %>%
  kable(format = "html", col.names = colnames(df_price)) %>%
  kable_styling() %>%
  kableExtra::scroll_box(width = "100%", height = "300px")

df_totconsumpcapita[1:150,] %>% 
  kable(format = "html", col.names = colnames(df_totconsumpcapita)) %>% 
  kable_styling() %>% 
  kableExtra::scroll_box(width = "100%", height = "300ppx")

```


```{r results = 'asis'}

entity <- 'Spain'

df_capacity <- df_capac %>% filter(Entity == entity) %>% select(-c(Entity, Code))
df_capita <- df_capit %>% filter(Entity == entity) %>% select(-c(Entity, Code))
df_primary <- df_prim %>% filter(Entity == entity) %>% select(-c(Entity, Code))
df_share <- df_shar %>% filter(Entity == entity) %>% select(-c(Entity, Code))
df_consumption <- df_consump %>% filter(Entity == entity) %>% select(-c(Entity, Code))
df_cumcap <- df_cumcapac %>% filter(Entity == entity) %>% select(-c(Entity, Code))
df_totconsump <- df_totconsumpcapita %>% filter(Entity == entity) %>% select(-c(Entity, Code))
df_price <- select(df_price,-c(Entity, Code))

df <- merge(df_capacity,df_capita, by="Year", all = TRUE) #to fill the non existant values with NA
df <- merge(df,df_primary,by="Year", all = TRUE)
df <- merge(df,df_share,by="Year", all = TRUE)
df <- merge(df,df_consumption,by="Year", all = TRUE)
df <- merge(df,df_cumcap,by="Year", all = TRUE)
df <- merge(df,df_price,by="Year", all = TRUE)
df <- merge(df,df_totconsump,by="Year", all = TRUE)

df[is.na(df)] <- 0 #change NA to 0


```


# Apply stuff from the lectures

Check some info of the data

```{r results = 'asis'}

str(df) #str() is an alternative to summary() but more compact

```


Take the column we want to study in depth (per capita solar energy consumption in Spain)

```{r results = 'asis'}

cap_consump <- df$Solar.per.capita..kWh...equivalent[25:57] #25 because first data start there
tt<- 1:NROW(cap_consump)

```

Plot the data and the autocorrelation plot.

```{r results = 'asis'}

plot(tt, cap_consump, xlab="Time", ylab="Solar per capita kWh") #from 1989 to 2021
acf(cap_consump) #strong correlation with lag values, correlation is negative after 10 years.


```



```{r results = 'asis'}

##fit a linear regression model           (not sur if useful method)
fit1 <- lm(cap_consump ~ tt)
summary(fit1)

##plot of the model
plot(tt, cap_consump, xlab="Time", ylab="Solar per capita kWh")
abline(fit1, col=3)

##check the residuals? are they autocorrelated? Test of DW
dwtest(fit1)

##check the residuals
resfit1<- residuals(fit1)
plot(resfit1,xlab="Time", ylab="residuals" )


```



```{r results = 'asis'}

##let us do the same with a linear model for time series, so we transform the data into a ts object
cap_consump.ts <- ts(cap_consump)
ts.plot(cap_consump.ts, type="o")

## we fit a linear model with the tslm function
fitts<- tslm(cap_consump.ts~trend)

###obviously it gives the same results of the first model
summary(fitts)

dwtest(fitts)

```



```{r results = 'asis'}

#plot(cap_consump, type="b")
plot(cap_consump, type= "b",xlab="Year", ylab="Solar per capita kWh",  pch=16, lty=3, xaxt="n", cex=0.6)
plot(cumsum(cap_consump), type="b", xlab="Year", ylab="Solar per capita kWh",  pch=16, lty=3, xaxt="n", cex=0.6)

```

# Bass Model

Let's now fit a Bass model.

```{r results = 'asis'}

bm_cap<-BM(cap_consump,display = T)
summary(bm_cap)

###prediction (out-of-sample)
pred_bmcap<- predict(bm_cap, newx=c(1:50))
pred.instcap<- make.instantaneous(pred_bmcap)

###plot of fitted model 
plot(cap_consump, type= "b",xlab="Year", ylab="Solar per capita kWh",  pch=16, lty=3, xaxt="n", cex=0.6)
lines(pred.instcap, lwd=2, col=2)

```

Predict (out-of-sample).

```{r results = 'asis'}

pred_bmcap<- predict(bm_cap, newx=c(1:50))
pred.instcap<- make.instantaneous(pred_bmcap)

```

Plot of fitted model

```{r results = 'asis'}

### 
plot(cap_consump, type= "b",xlab="Year", ylab="Solar per capita kWh",  pch=16, lty=3, xaxt="n", cex=0.6)
lines(pred.instcap, lwd=2, col=2)

```


Let's see what happens when we estimate the model with 75 percent of the data.

```{r results = 'asis'}

bm_cap75<-BM(cap_consump[1:25],display = T)
summary(bm_cap75)

# prediction
pred_bmcap75<- predict(bm_cap75, newx=c(1:50))
pred.instcap75<- make.instantaneous(pred_bmcap75)

# plotting
plot(cap_consump, type= "b",xlab="Year", ylab="Solar per capita kWh",  pch=16, lty=3, xaxt="n", cex=0.6)
lines(pred.instcap75, lwd=2, col=2)

```


Plot both models to compare them. 

```{r results = 'asis'}

###Comparison between models (instantaneous)
###instantaneous
plot(cap_consump, type= "b",xlab="Year", ylab="Solar per capita kWh",  pch=16, lty=3, xaxt="n", cex=0.6)
lines(pred.instcap75, lwd=2, col=2)
lines(pred.instcap, lwd=2, col=4)

###Comparison between models (cumulative)
plot(cumsum(cap_consump), type= "b",xlab="Year", ylab="Annual sales",  pch=16, lty=3, xaxt="n", cex=0.6)
lines(pred_bmcap75, lwd=2, col=2)
lines(pred_bmcap, lwd=2, col=4)

```

# Generalized bass model

```{r results = 'asis'}


 
# GBMe2 <- GBM(cap_consump,shock = "exp",nshock = 2,prelimestimates = c(1.243162e+04, 2.424655e-05, 3.283666e-01, 20, -0.1,0.2, 30,0.5,0.6))
# 
# GBMe2 <- GBM(cap_consump,shock = "exp",nshock = 2,prelimestimates = c(1.243162e+04, 2.424655e-05, 3.283666e-01, 20, -0.1,0.2, 30,0.5,0.7))


GBMe2 <- GBM(cap_consump,shock = "exp",nshock = 2,prelimestimates = c(1.243162e+04, 2.424655e-05, 3.283666e-01, 19, -0.1,0.2, 29,0.2,0.4))
summary(GBMe2)


# Try with three shocks
# GBMe2 <- GBM(cap_consump,shock = "exp",nshock = 3,prelimestimates = c(1.243162e+04, 2.424655e-05, 3.283666e-01, 18,-0.6,0.3, 21, -0.4,0.4, 29,0.38,0.5))

###

pred_GBMe2<- predict(GBMe2, newx=c(1:50))
pred_GBMe2.inst<- make.instantaneous(pred_GBMe2)

plot(cap_consump, type= "b",xlab="Quarter", ylab="Quarterly revenues",  pch=16, lty=3, cex=0.6, xlim=c(1,60))
lines(pred_GBMe2.inst, lwd=2, col=2)




```

# GGM

```{r results = 'asis'}

######GGM 
GGM_cap<- GGM(cap_consump, prelimestimates=c(1.243162e+04, 0.01, 0.01,  2.424655e-05, 3.283666e-01))
summary(GGM_cap)

pred_GGM_cap<- predict(GGM_cap, newx=c(1:60))
pred_GGM_cap.inst<- make.instantaneous(pred_GGM_cap)

plot(cap_consump, type= "b",xlab="Quarter", ylab="Quarterly revenues",  pch=16, lty=3, cex=0.6, xlim=c(1,60))
lines(pred_GGM_cap.inst, lwd=2, col=2)

```


```{r results = 'asis'}

###Analysis of residuals
res_GGM_cap<- residuals(GGM_cap)
acf<- acf(residuals(GGM_cap))


fit_GGM_cap<- fitted(GGM_cap)
fit_GGM_cap_inst<- make.instantaneous(fit_GGM_cap)

```


# Arima

```{r results = 'asis'}

# Let's begin with Arima

# autoplot(cap_consump)

plot(cap_consump)
Acf(cap_consump)
Pacf(cap_consump)

```


```{r results = 'asis'}
# Fit Arima model
arima1<- Arima(cap_consump, order=c(2,1, 0))
fitted(arima1)

# See effect of differenciation 
diff1<- diff(cap_consump) ##first difference
diff2<- diff(cap_consump, lag=2)
tsdisplay(diff1)
tsdisplay(diff2)


# Analyze residuals
resid1<- residuals(arima1)
tsdisplay(resid1)

# Plot Arima model
plot(cap_consump)
lines(fitted(arima1), col=2)

# Forecast
for1<- forecast(arima1)
plot(for1)

```


```{r results = 'asis'}

# Try autoarima
auto.a <- auto.arima(cap_consump)
auto.a

# Plot fitting
plot(cap_consump)
lines(fitted(auto.a), col=2)

# Do forecast
autoplot(forecast(auto.a))

#Check residuals
checkresiduals(auto.a)




```



```{r results = 'asis'}
# Let's see the influence of the price of PV modules

price <- df$Solar.PV.Module.Cost..2019.US..per.W.[25:57]
plot(price)
plot(cumsum(price))
acf(price)
pacf(price)


# armax1 <- Arima(cap_consump, xreg = price, order = c(1,1,1))
armax1 <- auto.arima(cap_consump, xreg = price)
summary(armax1)
res1 <- residuals(armax1)
Acf(res1)

fitted(armax1)
plot(cap_consump)
lines(fitted(armax1), col = 2)


```



```{r results = 'asis'}

# Let's see the influence of the capacity of PV modules

capacity <- df$Solar.Capacity.x[25:57]
capacity.ts <- ts(capacity)
# ts.plot(capacity.ts, type="o")

plot(capacity)
plot(cumsum(capacity))
acf(capacity)
pacf(capacity)

armax1 <- auto.arima(cap_consump, xreg = capacity)
summary(armax1)
res1 <- residuals(armax1)
Acf(res1)

fitted(armax1)
plot(cap_consump)
lines(fitted(armax1), col = 2)


```



```{r results = 'asis'}

mod <- tslm(cap_consump.ts~trend+capacity.ts)
summary(mod)

fitted(mod)
plot(cap_consump.ts)
lines(fitted(mod), col = 2)

# Analysis of residuals - autocorelation?
plot(residuals(mod))
dw <- dwtest(mod, alt="two.sided")
tsdisplay(residuals(mod))

aar <- auto.arima(residuals(mod))
fitted(aar)

plot(cap_consump.ts)
lines(fitted(mod)+fitted(aar), col = 3)

```




```{r results = 'asis'}
#Inpecting if the installed solar energy capacity of Spain is influenced by the one of another country.

df_capac_transformed <- df_capac

#Create one columns per country, with years as row and solar capacity as value
df_capac_transformed <-  dcast(df_capac_transformed, Year ~ Entity) 

#remove all white space in name columns
names(df_capac_transformed) <- gsub(" ", ".", names(df_capac_transformed))

#Keep only countries
df_capac_transformed <- df_capac_transformed %>% select(-c("Africa.(BP)", "Asia", "Asia.Pacific.(BP)", "CIS.(BP)","Europe", "Europe.(BP)", "High-income.countries", "Lower-middle-income.countries", "Middle.East.(BP)", "North.America.(BP)", "Other.Africa.(BP)", "Other.Asia.Pacific.(BP)", "Other.CIS.(BP)", "Other.Europe.(BP)", "Other.Middle.East.(BP)", "Other.South.and.Central.America.(BP)", "South.and.Central.America.(BP)", "United.Arab.Emirates", "North.America", "South.Africa", "Upper-middle-income.countries", "World", "Oceania" ))


str((df_capac_transformed))
df_capac_transformed[is.na(df_capac_transformed)] <- 0 #Convert NA to 0

#Convert df_capac_tansformed to a time series
#df_capac_transformed.zoo <- read.zoo(df_capac_transformed)
#df_capac_transformed.ts <- as.ts(df_capac_transformed.zoo) 

#Using Pearson correlation, Spain vs all
cor_spain_vs_all <- cor(df_capac_transformed[ , colnames(df_capac_transformed) != "Spain"], df_capac_transformed$Spain)
cor_spain_vs_all #Portugal with 0.9449656, Belgium 0.9423068 and Australia 0.9409159 are the country with higher Pearson correlation. Lets look at cross-correlation function (using lagged values of these countrie to predict current value of Spain)

ccf_spain_portugal <- ccf(df_capac_transformed$Portugal, df_capac_transformed$Spain,26) 

ccf_spain_belgium <- ccf(df_capac_transformed$Belgium, df_capac_transformed$Spain,26)

ccf_spain_australia <- ccf(df_capac_transformed$Australia, df_capac_transformed$Spain,26)
#from correlogram plot, it doesnt seems like the spending of any of theses three countries in solar capacity leads to en increase in spending in solar capacity for spain. They are correlatated, but the lagged values of theses three countries doesnt have a impact of current value of Spain, and it seems that is might be the opposite. 



#plotting Cross correlation function of every countries againts spain to see if we can see if some countries spedind leads to spain spending. I am not able to plot with the columns.
ccf_spain_vs_all <- sapply(df_capac_transformed, function(col_names) ccf(col_names,df_capac_transformed$Spain,26))
#from all correlogram, no lagged values of countries seems to influence spain spending.

```





```{r results = 'asis'}
#Analyszing relationship between Installed solar energy capacity and solar PV modul price

df_price_cap <- df[32:57,] %>% select(Year, Solar.Capacity.x, Solar.PV.Module.Cost..2019.US..per.W.) ##[32:55] to avoid 0 values of df_price

#Creat variable time and variable to not affect df_price_cap
t <- 1:NROW(df_price_cap)
df_p_c <- df_price_cap

#make plot
plot(t, df_p_c$Solar.Capacity.x, xlab = "Time", ylab = "Solar Capacity")
plot(t, df_p_c$Solar.PV.Module.Cost..2019.US..per.W., xlab = "Time", ylab = "Solar PV Price")

ggplot(df_p_c, aes(t)) +                    # basic graphical object
  geom_line(aes(y=df_p_c$Solar.Capacity.x, colour="Capacity")) +
  geom_line(aes(y=df_p_c$Solar.PV.Module.Cost..2019.US..per.W., colour="Price"))+
  scale_colour_manual("", 
                      breaks = c("Capacity", "Price"),
                      values = c("Capacity"="green", "Price"="red")) +
  xlab(" ") +
  scale_y_continuous("Amount", limits = c(0,10)) + 
  labs(title="Years")

#acf
acf(df_p_c,15)
ccf(df_p_c$Solar.Capacity.x, df_p_c$Solar.PV.Module.Cost..2019.US..per.W.,15)

#Fit linear regression model
fitcc <- lm(df_p_c$Solar.PV.Module.Cost..2019.US..per.W.~ df_p_c$Solar.Capacity.x, df_p_c)
summary(fitcc)
#summary analysis: Residual: average price of 4.34 for Solar PV modul. For an increase of 1 gigawatts, the price of PV modul drop of 0.50241usd$ per watts with a variation of 0.06389usd$ per watts. T-value significantly bigger than zero and their standard-errors, indicating that the coefficients are relatively bigger enough from their standor-errors. P-value smaller than 5% and three start, thus p-value significant enough to reject null hypothesis which mean there is a relationship between solar capacity and solar PV modul price. The residual standard error is 1.115, which represent 1.115/4.34312= 25.6% deviation error. R-squared of 0.7204, which mean that 72% of the variance of the solar PV modul price can be described by the solar capacity. F-Statistic larger than 1 significantly for 24 DF, meaning strong indication we can reject null hypothesis of no relationship.


##plot of the model
plot(df_p_c$Solar.Capacity.x, df_p_c$Solar.PV.Module.Cost..2019.US..per.W., xlab="Solar Capacity", ylab="Solar PV Price")
abline(fitcc, col=3) #The abline() function can be used to add vertical,
                     #horizontal or regression lines to plot.

##check the residuals? are they autocorrelated? Test of DW
dwtest(fitcc) #reject null hypothesis, thus they are autocorrelated.

##check the residuals
resfitcc<- residuals(fitcc) 
plot(resfitcc,xlab="Solar Capacity", ylab="residuals" )

#I dont perform BM, GBM, GGM, UCRCD since the two variable aren't in competition. Is that OK ?


#Local regression
y <-  df_p_c$Solar.PV.Module.Cost..2019.US..per.W.
x <-  df_p_c$Solar.Capacity.x

plot(x,y, xlab="Solar capacity", ylab="Solar PV modul price")

sm.regression(x, y, h= 10, add= T)

#lets increase the number of points where the function is calculated
sm.regression(x, y, h= 10, add= T, ngrid=200,col=2)

#Trying different value for h: higher h = smoother function.
sm.regression(x, y,   h = 30, ngrid=200, col=1)
sm.regression(x, y,   h = 50, add = T, ngrid=200, col=2)
sm.regression(x, y,   h = 5,  add = T, ngrid=200, col=3)
sm.regression(x, y,   h = 1,  add = T, col=3, ngrid=200)

#We add variability bands
sm.regression(x, y,   h = 30, ngrid=200, display="se")

#Loess (Locally Weighted Least Squares Regression). it uses more local data to estimate our Y variable. But it is also known as a variable bandwidth smoother, in that it uses a 'nearest neighbors' method to smooth.

lo1 <- loess.smooth(x,y) 
lines(lo1) #default span = 0.75

lo2 <- loess.smooth(x,y,span=0.9)
lines(lo2,col=2)
lo3 <- loess.smooth(x,y,span=0.4)
lines(lo3,col=3)

#another way to perform loess, performs directly the plot
#default span= 2/3
scatter.smooth(x,y) 
scatter.smooth(x,y, span=0.3)
scatter.smooth(x,y, span=0.3, evaluation=200)

###Regression splines (cubic splines)
plot(x,y,xlab="Solar capacity", ylab="Solar PV modul price")

#We select and identify the knots 'equispaced'
xi<-seq(min(x), max(x), length=4)

#2 internal knots
m1cc<-lm(y ~ bs(x, knots=xi[2:(length(xi)-1)], degree=3))

#Select 200 points
xxx<-seq(min(x),max(x),length=200)

#Make predictions by using the 'xxx' points
fit1<-predict(m1cc, data.frame(x=xxx))

plot(x,y,xlab="Solar capacity", ylab="Solar PV modul price")
lines(xxx,fit1,col=2)

######vertical lin3 to indicate the knots
abline(v=xi[2], lty=3)
abline(v=xi[3], lty=3)

###Selecting number of knots

plot(x,y,xlab="Solar capacity", ylab="Solar PV modul price")

# first model with 2 internal knots
m1cc<-lm(y~bs(x, df=5, degree=3)) 
fit1<-predict(m1cc, data.frame(x=xxx))
lines(xxx,fit1,col=4)

# second model with no internal knots 
m2cc <- lm(y ~ bs(x, df=3, degree=3)) 
fit2<-predict(m2cc,data.frame(x=xxx))
#plot(x,y,xlab="engine size", ylab="distance")
lines(xxx,fit2,col=3)

# Third model with 17 knots 
m3cc<-lm(y~bs(x,df=20,degree=3))
fit3<-predict(m3cc,data.frame(x=xxx))

#plot(x,y,xlab="engine size", ylab="distance")
lines(xxx,fit3,col=2)

###Smoothing splines
plot(x,y,xlab="engine size", ylab="distance")
s <- smooth.spline(x,y)
lines(s)

# Model 1
plot(x,y,xlab="engine size", ylab="distance")
s1 <- smooth.spline(x,y, lambda=0.0001)
lines(s1)
#
p1<- predict(s1, x=xxx)
lines(p1, col=2)
#
# Model 2
s2 <- smooth.spline(x,y, lambda=0.00001)
p2<- predict(s2, x=xxx)
lines(p2, col=3)
#
# Model 3
s3 <- smooth.spline(x,y, lambda=0.01)
p3<- predict(s3, x=xxx)
lines(p3, col=4)

# Model 4
s4 <- smooth.spline(x,y, lambda=1)
p4<- predict(s4, x=xxx)
lines(p4, col=4)

# Model 5
s5 <- smooth.spline(x,y, lambda=0.00000001)
p5<- predict(s5, x=xxx)
lines(p5, col=4)


#Perform GAM ? (Lab 4 end)

```

## Performing forecast



```{r results = 'asis'}




```





```{r results = 'asis'}




```





```{r results = 'asis'}




```





```{r results = 'asis'}




```





```{r results = 'asis'}




```





```{r results = 'asis'}




```




```{r results = 'asis'}




```




```{r results = 'asis'}




```




```{r results = 'asis'}




```




```{r results = 'asis'}




```
